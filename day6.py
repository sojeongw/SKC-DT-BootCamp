# -*- coding: utf-8 -*-
"""
Created on Wed Sep 18 09:17:54 2019

@author: user
"""

# =============================================================================
# ttest_1samp: 단일 집단
# ttest_ind: 두 집단. 독립. 동일한 성향의 표본 즉, 다른 요인이 전혀 없이 모두 똑같은 표본에게 하나는 A약, 하나는 B약을 준 것. 왜곡을 시킬 요인이 전혀 들어가있지 않은 상황. 
# ttest_rel: 두 집단. 대응 또는 쌍. 한 집단은 약에 민감하고 한 집단은 약에 둔감한 사람일 때. 그래서 이 때는 한 사람의 변동량을 본다.
# =============================================================================


# =============================================================================
# 난수 데이터로 판별하기
import scipy.stats as sc
import numpy as np

# 난수 생성값을 같게 하기 위해 int 값으로 시점을 지정한다. 
# random seed는 랜덤 함수에 한 번 적용되므로 난수 뽑기 직전에 한다.
np.random.seed(0)

# 난수 생성
x=sc.norm(0, 1).rvs(100)
# 참고) 매트릭스 형태로 난수 생성하는 방법 
# x=np.random.randn()

np.mean(x)

# 단일 표본 평균 검정
# t는 표준화된 value
# 평균값이 0에 가까우므로 popmean=0

# 만약 평균값을 5로 설정하면 p-value가 4.9199777735670015e-71 즉, 거의 0이 나온다.
# p-value가 0이라는 건 왼쪽 끝에 붙어있다는 뜻이다. 뮤가 5인지 아닌지 물었을 때 5가 아니다 라는 것. 귀무가설은 5이다 이고, 대립가설은 뮤가 5가 아니다 이다. 
# t값(staticstic)이 -48이라는 건 5라는 숫자가 

# p-value는 그래프 상에서 양쪽을 다 더한 값이다. 즉, 2배 한 값과 같다.
sc.ttest_1samp(x, popmean=5)

# 결과값
# 유의수준이 0.05 기준일 때, 유의 확률이 0.05556이므로 p 값이 크다.
# 따라서 귀무가설을 기각할 수 없다.
# Ttest_1sampResult(statistic=0.5904283402851698, pvalue=0.5562489158694675)
# =============================================================================


# =============================================================================
# sleep 데이터 이용하기
import pandas as pd

sleep=pd.read_csv("dataset/sleep.csv")

# 평균 = X bar
sleep.extra.mean()
# 표준편차
sleep.extra.std()
# 실제 데이터 개수 = X의 sample(표본) 수
len(sleep.extra)
# 표본 통계량 t statistic = (평균 X bar - 모집단의 평균인 뮤 0) / (x의 표준편차/x의 샘플 데이터 수를 루트 씌운 값)

# 수면양이 늘었는지 줄었는지 알고 싶은 것이므로 extra의 데이터를 넘긴다. 데이터의 변동량이 없다는 귀무가설을 세우고 싶으면 popmean에 0을 넣는다. 양수를 넣으면 평소보다 잠의 양의 증가했다는 가설, 음수를 넣으면 잠의 양이 감소된다는 의미이다. 비교하고자 하는 데이터에 맞게 값을 넣어야 한다.

# p-value가 유의수준보다 작으므로 그래프상에서 밖에 있는 것. 즉, 귀무가설을 기각시킨다 = 감기약으로 수면양이 증가한다.
# popmean=0이라는 건 변화가 없다는 의미다.
# 귀무가설 h0 = 감기가 걸리더라도 수면양에는 변화가 없다.
# 대립가설 h1 = 감기에 걸리면 수면 양에 변화가 있다.
sc.ttest_1samp(sleep.extra, popmean=0)

# 약 안 먹은 사람을 대상으로 할 때
sc.ttest_1samp(sleep.extra[0:10], 0)
# 약 안 먹은 그룹을 하고 싶은데 인덱스 번호를 모를 때
sc.ttest_1samp(sleep[sleep.group==1]["extra"], 0)
# Ttest_1sampResult(statistic=1.3257101407138212, pvalue=0.2175977800684489)
# 결과값을 해석해보면 p-value가 0.21이므로 귀무가설을 기각할 수 없음.

# 그룹 간의 차이를 보려고 할 때
# 1. ttest_ind: 독립인 두 집단간의 비교. 독립이란, 환자 자체에 데이터를 오염시킬 수 있는 성분이 없는 것. 두 집단간의 연관성이 없는 것.
# H0: 뮤a = 뮤b, 즉 a 집단의 평균과 b 집단의 평균이 같다. -> 뮤a - 뮤b = 0
# H1: 두 집단의 평균이 같지 않다. -> 뮤a - 뮤b는 0이 아니다.
# (a에 대한 평균 a bar - b에 대한 평균 b bar) = X bar
# X bar - 뮤a - 뮤b -> 즉, X bar - 0
# 여기서 표준편차를 구하려면 (X bar - 0) / (a bar와 b bar를 반영하는 표준편차)
# a와 b를 모두 반영하는 이유는 분자에서 뮤 a와 뮤 b가 존재하기 때문 
# 정리하면 (a_bar - b_bar) - (0[mu_a - mu_b])/sd(a_bar + b_bar)
# 각각의 표준편차 sd(a_bar + b_bar) = sd(a)/sqrt(a_n) + sd(b)/sqrt(b_n)
# 얘를 한 번에 루트를 씌우기 위해 분산(variance)를 사용하면 sqrt(var(a)/a_n + var(b)/b_n) 
# 최종적으로 (a_bar - b_bar) - (0[mu_a - mu_b]) / sqrt(var(a)/a_n + var(b)/b_n)
# =============================================================================


# =============================================================================
# 전제조건: 분산이 등산인지 검정
# 서로 분산이 같은지 확인헤야 하므로 분산이 같으니까 같게 돌려달라고 옵션을 지정해야한다.
# 등분산 검정을 진행한 후 ttest로 넘어가게 된다.

# 등분산 검정의 귀무가설 H0: a의 분산과 b의 분산이 같다. -> f값을 이용한다.
# 대립가설 H1: a와 b의 분산이 같지 않다.
# 위의 내용을 검정한 다음 ttest로 넘어간다.

# 그룹 별로 데이터를 나눈다.
x1=sleep[sleep.group==1]
y1=sleep[sleep.group==2]

# 그 중에서 extra인 값을 대상으로 비교한다.
sc.bartlett(x1.extra, y1.extra)
# BartlettResult(statistic=0.10789210747557532, pvalue=0.7425568224059087)
# 끼워맞춘 값이 0.107인데 이게 어느 위치에 있는지 보기 위해 p-value를 보면 0.742이므로 귀무가설을 기각할 수 없다. 즉, 둘은 등분산이다. 만약 p-value가 0.05보다 작다면 기각되어 이분산이라고 결론을 내릴 수 있다.

# parameter 중에 equal_var는 분산이 같은지를 판단하는 값이다. 따라서 여기서는 true로 쓴다.
sc.ttest_ind(x1.extra, y1.extra, equal_var=True)
# Ttest_indResult(statistic=-1.8608134674868526, pvalue=0.07918671421593818)
# p-value가 0.079이므로 최종적으로 귀무가설을 기각할 수 없다. 즉, 약을 먹고 안 먹고에 차이가 없다.
# 저번 시험에서는 같은 데이터를 써도 귀무가설을 기각할 수 있었다. 여기서는 개인의 특성을 따지지 않았기 때문이다. 각자 약에 대한 면역력이 다를 수도 있고 알러지가 있을 수도 있으니까. 개인차를 따지지 않고 각각의 값들을 그냥 하나의 평균, 대표값으로 퉁쳐서 비교한 것이다.
# 만약 나이키와 아디다스의 마모율을 테스트한다고 해보자. 사람들마다 성향이 다르다. 나이키가 마모율이 아무리 낮아도 하루에 10시간 이상 걷는 사람에게 줬다면 검증이 잘못되는 것이다. 순수 마모율만 점검하도록 설계하려면 똑같은 스케줄, 똑같은 압력, 똑같은 속도로 테스트하도록 만들어줘야 한다. 그래야 다른 요인이 섞이지 않는다. 따라서 기계에서 이러한 조건을 주고 테스트하는 것이다.

# 대응인 두 집단간의 차이 검정: 짝. 개인차가 빠지도록 검정하는 것
# 여기서는 등분산이 필요없다. 개인차를 뺀 값만 가지고 할 것이기 때문이다.
# x1의 첫번째 값 - y1의 첫번째 값 = d1
# x1의 두번째 값 - y1의 두번째 값 = d2 ....
# 이렇게 아예 처음부터 개인차를 없애고 새로운 변수를 만들어 사용한다. 즉, 최종적으로 10개의 데이터가 새로 생긴다.
# 뮤는 0이 된다. 차이를 빼줬기 때문에 평균에 차이가 없다는 의미다.
# (d_bar - 뮤 0) / (d_std/np.sqrt(d_n))
# 한 사람의 비포 애프터를 보는 상황에 적합하다. 약 먹기 전과 약 먹은 후의 개인 차를 없앤다.

# 만약 데이터가 서로 정렬되어 있지 않다면 먼저 group과 ID 칼럼으로 groupby를 해주고, 최종적으로 보고 싶은 값인 extra를 써준다.
rel_data=sleep.groupby(["group", "ID"])["extra"]

sc.ttest_rel(x1.extra, y1.extra)
# Ttest_relResult(statistic=-4.062127683382037, pvalue=0.00283289019738427)
# statistic은 앞의 값 - 뒤의 값 이므로 음수가 나오기도 하고 양수가 나오기도 한다.
# 여기서는 y값이 더 크다는 걸 알 수 있다.
# t값이 음수라고 해서 수면양이 줄었다고 생각해서는 안된다. 값의 배치를 봐야한다.

# 순서를 바꿔서 (y1. extra, x1.extra)로 하면 양수가 나온다. 즉, 약 복용 후가 약 복용 전보다 수면양이 늘어난다는 의미를 알게 된다.
sc.ttest_rel(y1.extra, x1.extra)
# 귀무가설이 기각되었다. 즉, 약 복용 여부에 따라 수면에 차이가 있으며, 값을 제대로 배치했으니 수면 양이 증가했다는 것을 알 수 있다.
# 개인 차를 빼고 잠의 변동량만을 봤을 때 이렇게 결과가 다르게 나온다.

# =============================================================================


# =============================================================================
# 여러 열을 합치는 다양한 방법들

rel_data=sleep.groupby(["group", "ID"])["extra"]

# groupby로 집계된 내용 보기
for i, j in rel_data:
  print(i)
  print(j)

# groupby는 extra를 인덱스로 묶는 기능밖에 없다. 어떻게 정리할지는 지정해줘야 한다.
# unstack()으로 인덱스별로 쌍으로 들어가게 한다.
# level=0이라고 하면 0을 기준으로 열을 바꾼다는 것이다. 묶었던 기준을 말하는 것. 여기선 group이 된다. 1이면 ID 별로 group 1,2가 묶인다.
rel_data1=rel_data.mean()   # 마지막 level 수준 별로 mean을 낸다.
rel_data2=rel_data1.unstack(level=0)
rel_data2=rel_data1.unstack(level=1)
rel_data3=rel_data.mean(level=0)    # level에 따라 mean을 낼 수 있다.


# 값 자체를 인덱스로 지정하려면 여러 개를 하나의 인덱스로 묶는 작업을 해준다.
# 결국 groupby와 같아진다.
index1=pd.MultiIndex.from_frame(sleep[["group","ID"]])

sleep2=pd.DataFrame(dict(extra=sleep["extra"].values), index=index1)

sleep3=pd.DataFrame(sleep["extra"].values, index=index1)

sleep4=sleep2.unstack(level=0)

# merge하면서 자동적으로 extra_x와 extra_y를 구분해 만들어준다.
sleep5=pd.merge(sleep[sleep.group==1][["extra","ID"]], sleep[sleep.group==2][["extra","ID"]], on="ID")

# 빼기 처리한 값을 하나의 열로 만들어서 처리할 수도 있다.
sleep5["x_y"]=sleep5["extra_y"]-sleep5.extra_x

sc.ttest_rel(sleep5.extra_x, sleep5.extra_y)
# Ttest_relResult(statistic=-4.062127683382037, pvalue=0.00283289019738427)

# 1samp은 기준값이 없기 때문에 같다는 의미의 0을 넣어줘야 한다.
sc.ttest_1samp(sleep5["x_y"], 0)
# =============================================================================
